#!/usr/bin/env python3
"""
SmartThings Token Manager ‚Äî Timed Auto Refresh + Verified Overwrite
-------------------------------------------------------------------
‚úì Uses Basic Auth for SmartThings OAuth
‚úì Refreshes tokens every X minutes
‚úì Verifies file overwrite after each update
‚úì Keeps a history log of every run
‚úì Full request/response logging + backups
"""

import base64, requests, json, os, time, shutil, urllib3
from datetime import datetime

# ==========================================================
# CONFIGURATION
# ==========================================================
TOKEN_FILE   = "token.txt"
BACKUP_DIR   = "backups"
LOG_DIR      = "logs"
HISTORY_LOG  = "token_refresh_history.log"

TOKEN_URL    = "https://auth-global.api.smartthings.com/oauth/token"
REFRESH_INTERVAL_MINUTES = 60     # ‚è± Adjust this value
VERIFY_SSL   = False              # ‚ö†Ô∏è True for production

os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(BACKUP_DIR, exist_ok=True)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


# ==========================================================
# UTILITIES
# ==========================================================
def timestamp():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def backup_file(path):
    if os.path.exists(path):
        dst = os.path.join(BACKUP_DIR, f"token_{datetime.now().strftime('%Y%m%d_%H%M%S')}.bak")
        shutil.copy2(path, dst)
        print(f"üóÉÔ∏è  Backup saved: {dst}")

def log_json(data, prefix):
    path = os.path.join(LOG_DIR, f"{prefix}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    print(f"ü™µ Log saved: {path}")

def append_history(entry):
    with open(HISTORY_LOG, "a", encoding="utf-8") as f:
        f.write(f"{timestamp()} ‚Äî {entry}\n")

def read_kv_file(path):
    creds = {}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if "=" in line:
                k,v=line.strip().split("=",1); creds[k.strip()]=v.strip()
    return creds


def write_kv_file(path, data):
    """Write safely with backup, then verify the overwrite."""
    backup_file(path)
    with open(path,"w",encoding="utf-8") as f:
        for k,v in data.items(): f.write(f"{k}={v}\n")

    # verification
    try:
        reloaded = read_kv_file(path)
        if reloaded.get("access_token") == data.get("access_token"):
            print(f"üíæ Verified: {path} updated successfully.")
            append_history("‚úÖ Verified token.txt overwrite succeeded.")
            return True
        else:
            print("‚ö†Ô∏è  Verification mismatch! Retrying write once...")
            append_history("‚ö†Ô∏è  token.txt verification mismatch ‚Äî retrying once.")
            with open(path,"w",encoding="utf-8") as f:
                for k,v in data.items(): f.write(f"{k}={v}\n")
            recheck = read_kv_file(path)
            if recheck.get("access_token") == data.get("access_token"):
                append_history("‚úÖ token.txt second write succeeded.")
                print("‚úÖ Second write succeeded.")
                return True
            else:
                append_history("‚ùå token.txt failed to update even after retry.")
                print("‚ùå token.txt overwrite verification failed.")
                return False
    except Exception as e:
        append_history(f"‚ùå token.txt verify error: {e}")
        print(f"‚ùå token.txt verify error: {e}")
        return False


def safe_json(resp):
    try: return resp.json()
    except Exception: return {"raw": resp.text}


# ==========================================================
# TOKEN FUNCTIONS (Basic Auth)
# ==========================================================
def make_basic_header(client_id, client_secret):
    token = f"{client_id}:{client_secret}"
    b64 = base64.b64encode(token.encode()).decode()
    return {"Authorization": f"Basic {b64}",
            "Content-Type": "application/x-www-form-urlencoded"}

def refresh_token(creds):
    """Perform token refresh using Basic Auth, with overwrite verification."""
    print("üîÅ Refreshing SmartThings token...")

    data = {
        "grant_type": "refresh_token",
        "refresh_token": creds["refresh_token"]
    }
    headers = make_basic_header(creds["client_id"], creds["client_secret"])
    resp = requests.post(TOKEN_URL, data=data, headers=headers, verify=VERIFY_SSL)

    log_json({
        "method": "POST", "url": TOKEN_URL,
        "data": data, "status": resp.status_code,
        "response": safe_json(resp)
    }, "token_refresh_request")

    if resp.status_code == 200:
        tokens = resp.json()
        creds.update({
            "access_token": tokens.get("access_token",""),
            "refresh_token": tokens.get("refresh_token", creds.get("refresh_token")),
            "expires_in": str(tokens.get("expires_in","86400")),
            "updated_at": timestamp()
        })
        success = write_kv_file(TOKEN_FILE, creds)
        if success:
            append_history("‚úÖ Token refresh and file update verified.")
            print("‚úÖ Token refresh and verification successful.")
        else:
            append_history("‚ö†Ô∏è Token refreshed but file verification failed.")
        return creds
    else:
        append_history(f"‚ùå Refresh failed ({resp.status_code}) ‚Äî {resp.text[:120]}")
        print(f"‚ùå Refresh failed ({resp.status_code}): {resp.text}")
        return creds


# ==========================================================
# LOOPING REFRESH SERVICE
# ==========================================================
def run_scheduler():
    print(f"üïí Starting SmartThings Token Auto-Refresher ‚Äî every {REFRESH_INTERVAL_MINUTES} min")
    append_history("‚ñ∂Ô∏è  Token refresher service started.")

    while True:
        try:
            creds = read_kv_file(TOKEN_FILE)
            refresh_token(creds)
        except Exception as e:
            msg = f"‚ö†Ô∏è Error during refresh: {e}"
            print(msg)
            append_history(msg)

        print(f"‚è≥ Sleeping {REFRESH_INTERVAL_MINUTES} minutes...")
        time.sleep(REFRESH_INTERVAL_MINUTES * 60)


# ==========================================================
# MAIN
# ==========================================================
if __name__ == "__main__":
    try:
        run_scheduler()
    except KeyboardInterrupt:
        print("\nüõë Stopped manually.")
        append_history("üõë Token refresher stopped manually.")